---
description: 
globs: 
alwaysApply: true
---

# Your rule content

- You can @ files here
- You can use markdown but dont have to

1. Давай все ответы на русском языке.
2. Названия переменных, параметров, свойств и методов начинаются со строчной буквы и записываются в нотации camelCase. Исключение составляют перечисления, они записываются в нотации PascalCase.
3. Массивы названы существительными во множественном числе.
4. Название функции или метода содержит глагол.
5. Название классов, конструкторов и перечислений начинается с заглавной буквы. В названии используются английские существительные. Значения перечислений объявлены как константы.
6. Все константы выносятся в начало модуля. Перечисления, как набор констант, также выносятся.
7. учитывать .eslintrc.js
8. Все файлы JS представляют собой отдельные модули ES2015, а название модуля соответствует его содержимому и записано строчными (маленькими) буквами, слова разделены дефисами. Модули не экспортируют изменяющиеся переменные.
9. Код является кроссбраузерным и не вызывает ошибок в разных браузерах и разных операционных системах. только в последних версиях браузеров: Chrome, Firefox, Safari, Microsoft Edge (на движке Blink). в Safari может не отображаться балун, реализованный с помощью Leaflet. Это не является ошибкой.
10. Обработчики событий документа (document) добавляются и удаляются своевременно.
11. Защита от memory-leak Количество обработчиков, подвешенных на глобальную область видимости, не должно возрастать. Например, если подвешивается обработчик, который следит за перемещением курсора по экрану, то он должен добавляться и удаляться в нужный момент. Случай, когда обработчик на document только добавляется, может свидетельствовать о проблеме бесконечного создания обработчиков и потенциальной утечке памяти.
12. Защита от неправильного поведения интерфейса Например, на странице может существовать попап, который скрывается по нажатию клавиши ESC. Лучше для него удалять обработчик события нажатия на клавишу, если он не показан, потому что он может каким-то образом ломать поведение сайта: останавливать распространение, отменять поведение по умолчанию и так далее.
13. Для вставки пользовательских строк (имён, фамилий и так далее) использован textContent.
14. Название методов и свойств объектов не содержит название объектов.
15. Именованные функции-обработчики событий названы в соответствии с правилами именования обработчиков.
16. Все функции объявлены единообразно. Используются стрелочные функции, если это не влияет на поведение функции.
17. Отсутствует дублирование кода: повторяющиеся части кода переписаны как функции.
18. Если функция возвращает булево значение, не используется if..else с лишними return. Там, где возможно, в присвоении значения вместо if используется тернарный оператор.
19. В коде не используются «магические значения», под каждое из них заведена отдельная переменная, названная как константа. Неправильно: setTimeout(doIt, 1000); Правильно: // Определим константу const TIMEOUT = 1000; setTimeout(doIt, TIMEOUT);
20. Поиск элементов по селекторам делается минимальное количество раз, после этого ссылки на элементы сохраняются.
21. Для каждого события используется отдельный обработчик.
22. Длинные функции и методы разбиты на несколько небольших.
23. Для работы с JS-коллекциями используются итераторы для массивов.
24. Отсутствует дублирование обработчиков событий. Если элемент интерфейса скрывается на время, при его появлении обработчики повторно не добавляются. При скрытии элемента удалять внутренние обработчики событий не нужно.

25. Техническое задание
О проекте
Кекстаграм — сервис просмотра изображений. Пользователям предоставлена возможность загружать свои фотографии или просматривать фотографии, загруженные ранее другими пользователями.

Описание функциональности
25.1. Загрузка нового изображения на сайт и заполнение информации о нём
25.1.1. Загрузка нового изображения:

выбор файла с изображением для загрузки;
изменение масштаба изображения;
применение одного из заранее заготовленных эффектов;
выбор глубины эффекта с помощью ползунка;
добавление текстового комментария;
добавление хэштегов.
25.1.2. Выбор изображения для загрузки осуществляется с помощью стандартного контрола загрузки файла .img-upload__input, который стилизован под букву «О» в логотипе. После выбора изображения (изменения значения поля .img-upload__input), показывается форма редактирования изображения. У элемента .img-upload__overlay удаляется класс hidden, а body задаётся класс modal-open.

После выбора изображения пользователем с помощью стандартного контрола загрузки файла .img-upload__input, нужно подставить его в форму редактирования вместо тестового изображения в блок предварительного просмотра и в превью эффектов.

25.1.3. Закрытие формы редактирования изображения производится либо нажатием на кнопку .img-upload__cancel, либо нажатием клавиши Esc. Элементу .img-upload__overlay возвращается класс hidden. У элемента body удаляется класс modal-open.

25.2. Редактирование изображения и ограничения, накладываемые на поля
25.2.1. Масштаб:

При нажатии на кнопки .scale__control--smaller и .scale__control--bigger должно изменяться значение поля .scale__control--value;
Значение должно изменяться с шагом в 25. Например, если значение поля установлено в 50%, после нажатия на «+», значение должно стать равным 75%. Максимальное значение — 100%, минимальное — 25%. Значение по умолчанию — 100%;
При изменении значения поля .scale__control--value изображению внутри .img-upload__preview должен добавляться соответствующий стиль CSS, который с помощью трансформации scale задаёт масштаб. Например, если в поле стоит значение 75%, то в стиле изображения должно быть написано transform: scale(0.75).
25.2.2. Наложение эффекта на изображение:

По умолчанию должен быть выбран эффект «Оригинал».
На изображение может накладываться только один эффект.
Интенсивность эффекта регулируется перемещением ползунка в слайдере. Слайдер реализуется сторонней библиотекой для реализации слайдеров noUiSlider. Уровень эффекта записывается в поле .effect-level__value в виде числа. При изменении уровня интенсивности эффекта (предоставляется API слайдера), CSS-стили картинки внутри .img-upload__preview обновляются следующим образом:
Для эффекта «Хром» — filter: grayscale(0..1) с шагом 0.1;
Для эффекта «Сепия» — filter: sepia(0..1) с шагом 0.1;
Для эффекта «Марвин» — filter: invert(0..100%) с шагом 1%;
Для эффекта «Фобос» — filter: blur(0..3px) с шагом 0.1px;
Для эффекта «Зной» — filter: brightness(1..3) с шагом 0.1;
Для эффекта «Оригинал» CSS-стили filter удаляются.
При выборе эффекта «Оригинал» слайдер и его контейнер (элемент .img-upload__effect-level) скрываются.
При переключении эффектов, уровень насыщенности сбрасывается до начального значения (100%): слайдер, CSS-стиль изображения и значение поля должны обновляться.
25.2.3. хэштеги:

хэштег начинается с символа # (решётка);
строка после решётки должна состоять из букв и чисел и не может содержать пробелы, спецсимволы (#, @, $ и т. п.), символы пунктуации (тире, дефис, запятая и т. п.), эмодзи и т. д.;
хеш-тег не может состоять только из одной решётки;
максимальная длина одного хэштега 20 символов, включая решётку;
хэштеги нечувствительны к регистру: #ХэшТег и #хэштег считаются одним и тем же тегом;
хэштеги разделяются пробелами;
один и тот же хэштег не может быть использован дважды;
нельзя указать больше пяти хэштегов;
хэштеги необязательны;
если фокус находится в поле ввода хэштега, нажатие на Esc не должно приводить к закрытию формы редактирования изображения.
25.2.4. Комментарий:

комментарий не обязателен;
длина комментария не может составлять больше 140 символов;
если фокус находится в поле ввода комментария, нажатие на Esc не должно приводить к закрытию формы редактирования изображения.
25.3. Отправка данных на сервер
25.3.1. После заполнения всех данных, при нажатии на кнопку «Отправить», все данные из формы, включая изображения, с помощью AJAX-запроса отправляются на сервер https://31.javascript.htmlacademy.pro/kekstagram методом POST с типом multipart/form-data. На время выполнения запроса к серверу кнопка «Отправить» блокируется.

25.3.2. Страница реагирует на неправильно введённые значения в форму. Если данные, введённые в форму, не соответствуют ограничениям, указанным в пунктах 2.3 и 2.4, форму невозможно отправить на сервер.

При попытке отправить форму с неправильными данными отправки не происходит, а пользователю показываются ошибки для неверно заполненных полей (для проверки данных используется сторонняя библиотека Pristine).

Ошибки выводятся внутри блока .img-upload__field-wrapper соответствующего поля. Также, если поле заполнено неверно, блоку, в котором выводится текст ошибки, добавляется класс .img-upload__field-wrapper--error.

Пример:

<div class="pristine-error img-upload__field-wrapper--error" style="">Неправильный хэштег</div>
Для разных ошибок показываются разные сообщения. Следует разделять случаи, когда:

введён невалидный хэштег;
превышено количество хэштегов;
хэштеги повторяются;
длина комментария больше 140 символов.
Количество одновременно показываемых сообщений для одного поля разработчик определяет самостоятельно.

25.3.3. При успешной отправке формы форма редактирования изображения закрывается, все данные, введённые в форму, и контрол фильтра приходят в исходное состояние:

масштаб возвращается к 100%;
эффект сбрасывается на «Оригинал»;
поля для ввода хэштегов и комментария очищаются;
поле загрузки фотографии, стилизованное под букву «О» в логотипе, очищается.
25.3.3. Если отправка данных прошла успешно, показывается соответствующее сообщение. Разметку сообщения, которая находится в блоке #success внутри шаблона template, нужно разместить перед закрывающим тегом </body>. Сообщение должно удаляться со страницы после нажатия на кнопку .success__button, по нажатию на клавишу Esc и по клику на произвольную область экрана за пределами блока с сообщением.

25.3.4. Если при отправке данных произошла ошибка запроса, нужно показать соответствующее сообщение. Разметку сообщения, которая находится в блоке #error внутри шаблона template, нужно разместить перед закрывающим тегом </body>. Сообщение должно удаляться со страницы после нажатия на кнопку .error__button, по нажатию на клавишу Esc и по клику на произвольную область экрана за пределами блока с сообщением. В таком случае вся введённая пользователем информация сохраняется, чтобы у него была возможность отправить форму повторно.

25.3.5. Нажатие на кнопку .img-upload__cancel приводит к закрытию формы и возвращению всех данных и контрола фильтра к исходному состоянию (описано в пункте 25.3.3). Поле загрузки фотографии, стилизованное под букву «О» в логотипе, очищается.

25.4. Просмотр загруженных изображений
25.4.1. Загрузка изображений от других пользователей производится сразу после открытия страницы с удалённого сервера: https://31.javascript.htmlacademy.pro/kekstagram/data.

25.4.2. Если при загрузке данных с сервера произошла ошибка запроса, нужно показать соответствующее сообщение. Разметку сообщения, которая находится в блоке #data-error внутри шаблона template, нужно разместить перед закрывающим тегом </body>. Сообщение удаляется со страницы через 5 секунд.

25.4.3. Все загруженные изображения показаны на главной странице в виде миниатюр. DOM-элемент миниатюры генерируется на основе шаблонного элемента picture, расположенного в элементе template на странице.

25.4.4. При нажатии на любую из миниатюр, показывается блок .big-picture, содержащий полноэкранное изображение с количеством лайков и комментариев. Элементу body задаётся класс modal-open. Данные, описывающие изображение, должны подставляться в соответствующие элементы в разметке.

25.4.5. Выход из полноэкранного режима просмотра фотографии осуществляется либо нажатием на иконку крестика .big-picture__cancel в правом верхнем углу блока .big-picture, либо нажатием на клавишу Esc. У элемента body удаляется класс modal-open.

25.4.6. Все комментарии к изображению выводятся в блок .social__comments. Сразу после открытия изображения в полноэкранном режиме отображается не более 5 комментариев. Количество показанных комментариев и общее число комментариев отображается в блоке .social__comment-count. Пример разметки списка комментариев приведён в блоке .social__comments. Комментарий оформляется отдельным элементом списка li с классом social__comment. Аватарка автора комментария отображается в блоке .social__picture. Имя автора комментария отображается в атрибуте alt его аватарки. Текст комментария выводится в блоке .social__text.

25.4.7. Отображение дополнительных комментариев происходит при нажатии на кнопку .comments-loader. При нажатии на кнопку отображается не более 5 новых комментариев. При изменении количества показанных комментариев число показанных комментариев в блоке .social__comment-count также изменяется.

25.4.8. Если все комментарии показаны, кнопку .comments-loader следует скрыть, добавив класс hidden.

25.5. Фильтрация изображений от других пользователей
25.5.1. Доступные фильтры:

«По умолчанию» — фотографии в изначальном порядке с сервера;
«Случайные» — 10 случайных, не повторяющихся фотографий;
«Обсуждаемые» — фотографии, отсортированные в порядке убывания количества комментариев.
25.5.2. Блок, с помощью которого производится фильтрация фотографий, скрыт изначально и показывается только после получения от сервера данных об изображениях других пользователей.

25.5.3. При переключении фильтров, отрисовка изображений, подходящих под новый фильтр, должна производиться не чаще, чем один раз 500 мс (устранение дребезга).
25.5.4. Функция debounce для устранения дребезга:
function debounce (callback, timeoutDelay = 500) {
  // Используем замыкания, чтобы id таймаута у нас навсегда приклеился
  // к возвращаемой функции с setTimeout, тогда мы его сможем перезаписывать
  let timeoutId;

  return (...rest) => {
    // Перед каждым новым вызовом удаляем предыдущий таймаут,
    // чтобы они не накапливались
    clearTimeout(timeoutId);

    // Затем устанавливаем новый таймаут с вызовом колбэка на ту же задержку
    timeoutId = setTimeout(() => callback.apply(this, rest), timeoutDelay);

    // Таким образом цикл «поставить таймаут - удалить таймаут» будет выполняться,
    // пока действие совершается чаще, чем переданная задержка timeoutDelay
  };
}       
      
Функция throttle для пропуска кадров:
function throttle (callback, delayBetweenFrames) {
  // Используем замыкания, чтобы время "последнего кадра" навсегда приклеилось
  // к возвращаемой функции с условием, тогда мы его сможем перезаписывать
  let lastTime = 0;

  return (...rest) => {
    // Получаем текущую дату в миллисекундах,
    // чтобы можно было в дальнейшем
    // вычислять разницу между кадрами
    const now = new Date();

    // Если время между кадрами больше задержки,
    // вызываем наш колбэк и перезаписываем lastTime
    // временем "последнего кадра"
    if (now - lastTime >= delayBetweenFrames) {
      callback.apply(this, rest);
      lastTime = now;
    }
  };
}